/* automatically generated by rust-bindgen 0.58.1 */

pub const KTX_ANIMDATA_KEY: &'static [u8; 12usize] = b"KTXanimData\0";
pub const KTX_ORIENTATION_KEY: &'static [u8; 15usize] = b"KTXorientation\0";
pub const KTX_SWIZZLE_KEY: &'static [u8; 11usize] = b"KTXswizzle\0";
pub const KTX_WRITER_KEY: &'static [u8; 10usize] = b"KTXwriter\0";
pub const KTX_WRITER_SCPARAMS_KEY: &'static [u8; 18usize] = b"KTXwriterScParams\0";
pub const KTX_ORIENTATION1_FMT: &'static [u8; 5usize] = b"S=%c\0";
pub const KTX_ORIENTATION2_FMT: &'static [u8; 10usize] = b"S=%c,T=%c\0";
pub const KTX_ORIENTATION3_FMT: &'static [u8; 15usize] = b"S=%c,T=%c,R=%c\0";
pub const KTX_GL_UNPACK_ALIGNMENT: u32 = 4;
pub const KTX_TRUE: u32 = 1;
pub const KTX_FALSE: u32 = 0;
pub const KTX_ENDIAN_REF: u32 = 67305985;
pub const KTX_ENDIAN_REF_REV: u32 = 16909060;
pub const KTX_HEADER_SIZE: u32 = 64;
pub type size_t = ::std::os::raw::c_ulong;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type FILE = [u64; 27usize];
pub type off_t = __off_t;
#[doc = " To avoid including <KHR/khrplatform.h> define our own types."]
pub type ktx_uint8_t = ::std::os::raw::c_uchar;
pub type ktx_bool_t = bool;
pub type ktx_uint16_t = u16;
pub type ktx_int16_t = i16;
pub type ktx_uint32_t = u32;
pub type ktx_int32_t = i32;
pub type ktx_size_t = size_t;
pub type ktx_uint64_t = u64;
pub type ktx_int64_t = i64;
#[doc = " This will cause compilation to fail if size of uint32 != 4."]
pub type ktx_uint32_t_SIZE_ASSERT = [::std::os::raw::c_uchar; 1usize];
pub type GLenum = ::std::os::raw::c_uint;
pub type GLuint = ::std::os::raw::c_uint;
#[doc = "< Operation was successful."]
pub const ktx_error_code_e_KTX_SUCCESS: ktx_error_code_e = 0;
#[doc = "< The data in the file is inconsistent with the spec."]
pub const ktx_error_code_e_KTX_FILE_DATA_ERROR: ktx_error_code_e = 1;
#[doc = "< The file is a pipe or named pipe."]
pub const ktx_error_code_e_KTX_FILE_ISPIPE: ktx_error_code_e = 2;
#[doc = "< The target file could not be opened."]
pub const ktx_error_code_e_KTX_FILE_OPEN_FAILED: ktx_error_code_e = 3;
#[doc = "< The operation would exceed the max file size."]
pub const ktx_error_code_e_KTX_FILE_OVERFLOW: ktx_error_code_e = 4;
#[doc = "< An error occurred while reading from the file."]
pub const ktx_error_code_e_KTX_FILE_READ_ERROR: ktx_error_code_e = 5;
#[doc = "< An error occurred while seeking in the file."]
pub const ktx_error_code_e_KTX_FILE_SEEK_ERROR: ktx_error_code_e = 6;
#[doc = "< File does not have enough data to satisfy request."]
pub const ktx_error_code_e_KTX_FILE_UNEXPECTED_EOF: ktx_error_code_e = 7;
#[doc = "< An error occurred while writing to the file."]
pub const ktx_error_code_e_KTX_FILE_WRITE_ERROR: ktx_error_code_e = 8;
#[doc = "< GL operations resulted in an error."]
pub const ktx_error_code_e_KTX_GL_ERROR: ktx_error_code_e = 9;
#[doc = "< The operation is not allowed in the current state."]
pub const ktx_error_code_e_KTX_INVALID_OPERATION: ktx_error_code_e = 10;
#[doc = "< A parameter value was not valid"]
pub const ktx_error_code_e_KTX_INVALID_VALUE: ktx_error_code_e = 11;
#[doc = "< Requested key was not found"]
pub const ktx_error_code_e_KTX_NOT_FOUND: ktx_error_code_e = 12;
#[doc = "< Not enough memory to complete the operation."]
pub const ktx_error_code_e_KTX_OUT_OF_MEMORY: ktx_error_code_e = 13;
#[doc = "< Transcoding of block compressed texture failed."]
pub const ktx_error_code_e_KTX_TRANSCODE_FAILED: ktx_error_code_e = 14;
#[doc = "< The file not a KTX file"]
pub const ktx_error_code_e_KTX_UNKNOWN_FILE_FORMAT: ktx_error_code_e = 15;
#[doc = "< The KTX file specifies an unsupported texture type."]
pub const ktx_error_code_e_KTX_UNSUPPORTED_TEXTURE_TYPE: ktx_error_code_e = 16;
#[doc = "< Feature not included in in-use library or not yet implemented."]
pub const ktx_error_code_e_KTX_UNSUPPORTED_FEATURE: ktx_error_code_e = 17;
#[doc = "< Library dependency (OpenGL or Vulkan) not linked into application."]
pub const ktx_error_code_e_KTX_LIBRARY_NOT_LINKED: ktx_error_code_e = 18;
#[doc = "< For safety checks."]
pub const ktx_error_code_e_KTX_ERROR_MAX_ENUM: ktx_error_code_e = 18;
#[doc = " @~English"]
#[doc = " @brief Error codes returned by library functions."]
pub type ktx_error_code_e = ::std::os::raw::c_uint;
#[doc = " @~English"]
#[doc = " @brief Result codes returned by library functions."]
pub use self::ktx_error_code_e as ktxResult;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxKVListEntry {
    _unused: [u8; 0],
}
#[doc = " @class ktxHashList"]
#[doc = " @~English"]
#[doc = " @brief Opaque handle to a ktxHashList."]
pub type ktxHashList = *mut ktxKVListEntry;
#[doc = " @class ktxHashListEntry"]
#[doc = " @~English"]
#[doc = " @brief Opaque handle to an entry in a @ref ktxHashList."]
pub type ktxHashListEntry = ktxKVListEntry;
pub const ktxOrientationX_KTX_ORIENT_X_LEFT: ktxOrientationX = 108;
pub const ktxOrientationX_KTX_ORIENT_X_RIGHT: ktxOrientationX = 114;
pub type ktxOrientationX = ::std::os::raw::c_uint;
pub const ktxOrientationY_KTX_ORIENT_Y_UP: ktxOrientationY = 117;
pub const ktxOrientationY_KTX_ORIENT_Y_DOWN: ktxOrientationY = 100;
pub type ktxOrientationY = ::std::os::raw::c_uint;
pub const ktxOrientationZ_KTX_ORIENT_Z_IN: ktxOrientationZ = 105;
pub const ktxOrientationZ_KTX_ORIENT_Z_OUT: ktxOrientationZ = 111;
pub type ktxOrientationZ = ::std::os::raw::c_uint;
pub const class_id_ktxTexture1_c: class_id = 1;
pub const class_id_ktxTexture2_c: class_id = 2;
pub type class_id = ::std::os::raw::c_uint;
#[doc = " @~English"]
#[doc = " @brief Struct describing the logical orientation of an image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxOrientation {
    #[doc = "< Orientation in X"]
    pub x: ktxOrientationX,
    #[doc = "< Orientation in Y"]
    pub y: ktxOrientationY,
    #[doc = "< Orientation in Z"]
    pub z: ktxOrientationZ,
}
#[test]
fn bindgen_test_layout_ktxOrientation() {
    assert_eq!(
        ::std::mem::size_of::<ktxOrientation>(),
        12usize,
        concat!("Size of: ", stringify!(ktxOrientation))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxOrientation>(),
        4usize,
        concat!("Alignment of ", stringify!(ktxOrientation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxOrientation>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxOrientation),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxOrientation>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxOrientation),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxOrientation>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxOrientation),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " @class ktxTexture"]
#[doc = " @~English"]
#[doc = " @brief Base class representing a texture."]
#[doc = ""]
#[doc = " ktxTextures should be created only by one of the provided"]
#[doc = " functions and these fields should be considered read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture {
    pub classId: class_id,
    pub vtbl: *mut ktxTexture_vtbl,
    pub vvtbl: *mut ktxTexture_vvtbl,
    pub _protected: *mut ktxTexture_protected,
    pub isArray: ktx_bool_t,
    pub isCubemap: ktx_bool_t,
    pub isCompressed: ktx_bool_t,
    pub generateMipmaps: ktx_bool_t,
    pub baseWidth: ktx_uint32_t,
    pub baseHeight: ktx_uint32_t,
    pub baseDepth: ktx_uint32_t,
    pub numDimensions: ktx_uint32_t,
    pub numLevels: ktx_uint32_t,
    pub numLayers: ktx_uint32_t,
    pub numFaces: ktx_uint32_t,
    pub orientation: ktxOrientation,
    pub kvDataHead: ktxHashList,
    pub kvDataLen: ktx_uint32_t,
    pub kvData: *mut ktx_uint8_t,
    pub dataSize: ktx_size_t,
    pub pData: *mut ktx_uint8_t,
}
#[test]
fn bindgen_test_layout_ktxTexture() {
    assert_eq!(
        ::std::mem::size_of::<ktxTexture>(),
        120usize,
        concat!("Size of: ", stringify!(ktxTexture))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxTexture>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxTexture))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).classId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(classId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).vtbl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(vtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).vvtbl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(vvtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>()))._protected as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(_protected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).isArray as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(isArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).isCubemap as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(isCubemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).isCompressed as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(isCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).generateMipmaps as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(generateMipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).baseWidth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(baseWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).baseHeight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(baseHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).baseDepth as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(baseDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).numDimensions as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(numDimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).numLevels as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).numLayers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(numLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).numFaces as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(numFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).orientation as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).kvDataHead as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(kvDataHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).kvDataLen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(kvDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).kvData as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(kvData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).dataSize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture>())).pData as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @memberof ktxTexture"]
#[doc = " @~English"]
#[doc = " @brief Signature of function called by the <tt>ktxTexture_Iterate*</tt>"]
#[doc = "        functions to receive image data."]
#[doc = ""]
#[doc = " The function parameters are used to pass values which change for each image."]
#[doc = " Obtain values which are uniform across all images from the @c ktxTexture"]
#[doc = " object."]
#[doc = ""]
#[doc = " @param [in] miplevel        MIP level from 0 to the max level which is"]
#[doc = "                             dependent on the texture size."]
#[doc = " @param [in] face            usually 0; for cube maps, one of the 6 cube"]
#[doc = "                             faces in the order +X, -X, +Y, -Y, +Z, -Z,"]
#[doc = "                             0 to 5."]
#[doc = " @param [in] width           width of the image."]
#[doc = " @param [in] height          height of the image or, for 1D textures"]
#[doc = "                             textures, 1."]
#[doc = " @param [in] depth           depth of the image or, for 1D & 2D"]
#[doc = "                             textures, 1."]
#[doc = " @param [in] faceLodSize     number of bytes of data pointed at by"]
#[doc = "                             @p pixels."]
#[doc = " @param [in] pixels          pointer to the image data."]
#[doc = " @param [in,out] userdata    pointer for the application to pass data to and"]
#[doc = "                             from the callback function."]
pub type PFNKTXITERCB = ::std::option::Option<
    unsafe extern "C" fn(
        miplevel: ::std::os::raw::c_int,
        face: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        faceLodSize: ktx_uint64_t,
        pixels: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e,
>;
#[doc = " Don't use KTX_APIENTRYP to avoid a Doxygen bug."]
pub type PFNKTEXDESTROY = ::std::option::Option<unsafe extern "C" fn(This: *mut ktxTexture)>;
pub type PFNKTEXGETIMAGEOFFSET = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        layer: ktx_uint32_t,
        faceSlice: ktx_uint32_t,
        pOffset: *mut ktx_size_t,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXGETDATASIZEUNCOMPRESSED =
    ::std::option::Option<unsafe extern "C" fn(This: *mut ktxTexture) -> ktx_size_t>;
pub type PFNKTEXGETIMAGESIZE = ::std::option::Option<
    unsafe extern "C" fn(This: *mut ktxTexture, level: ktx_uint32_t) -> ktx_size_t,
>;
pub type PFNKTEXITERATELEVELS = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        iterCb: PFNKTXITERCB,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXITERATELOADLEVELFACES = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        iterCb: PFNKTXITERCB,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXLOADIMAGEDATA = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        pBuffer: *mut ktx_uint8_t,
        bufSize: ktx_size_t,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXNEEDSTRANSCODING =
    ::std::option::Option<unsafe extern "C" fn(This: *mut ktxTexture) -> ktx_bool_t>;
pub type PFNKTEXSETIMAGEFROMMEMORY = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        layer: ktx_uint32_t,
        faceSlice: ktx_uint32_t,
        src: *const ktx_uint8_t,
        srcSize: ktx_size_t,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXSETIMAGEFROMSTDIOSTREAM = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        layer: ktx_uint32_t,
        faceSlice: ktx_uint32_t,
        src: *mut FILE,
        srcSize: ktx_size_t,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXWRITETOSTDIOSTREAM = ::std::option::Option<
    unsafe extern "C" fn(This: *mut ktxTexture, dstsstr: *mut FILE) -> ktx_error_code_e,
>;
pub type PFNKTEXWRITETONAMEDFILE = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        dstname: *const ::std::os::raw::c_char,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXWRITETOMEMORY = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ktxTexture,
        bytes: *mut *mut ktx_uint8_t,
        size: *mut ktx_size_t,
    ) -> ktx_error_code_e,
>;
pub type PFNKTEXWRITETOSTREAM = ::std::option::Option<
    unsafe extern "C" fn(This: *mut ktxTexture, dststr: *mut ktxStream) -> ktx_error_code_e,
>;
#[doc = " @memberof ktxTexture"]
#[doc = " @~English"]
#[doc = " @brief Table of virtual ktxTexture methods."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture_vtbl {
    pub Destroy: PFNKTEXDESTROY,
    pub GetImageOffset: PFNKTEXGETIMAGEOFFSET,
    pub GetDataSizeUncompressed: PFNKTEXGETDATASIZEUNCOMPRESSED,
    pub GetImageSize: PFNKTEXGETIMAGESIZE,
    pub IterateLevels: PFNKTEXITERATELEVELS,
    pub IterateLoadLevelFaces: PFNKTEXITERATELOADLEVELFACES,
    pub NeedsTranscoding: PFNKTEXNEEDSTRANSCODING,
    pub LoadImageData: PFNKTEXLOADIMAGEDATA,
    pub SetImageFromMemory: PFNKTEXSETIMAGEFROMMEMORY,
    pub SetImageFromStdioStream: PFNKTEXSETIMAGEFROMSTDIOSTREAM,
    pub WriteToStdioStream: PFNKTEXWRITETOSTDIOSTREAM,
    pub WriteToNamedFile: PFNKTEXWRITETONAMEDFILE,
    pub WriteToMemory: PFNKTEXWRITETOMEMORY,
    pub WriteToStream: PFNKTEXWRITETOSTREAM,
}
#[test]
fn bindgen_test_layout_ktxTexture_vtbl() {
    assert_eq!(
        ::std::mem::size_of::<ktxTexture_vtbl>(),
        112usize,
        concat!("Size of: ", stringify!(ktxTexture_vtbl))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxTexture_vtbl>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxTexture_vtbl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_vtbl>())).Destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(Destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_vtbl>())).GetImageOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(GetImageOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtbl>())).GetDataSizeUncompressed as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(GetDataSizeUncompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_vtbl>())).GetImageSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(GetImageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_vtbl>())).IterateLevels as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(IterateLevels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtbl>())).IterateLoadLevelFaces as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(IterateLoadLevelFaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtbl>())).NeedsTranscoding as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(NeedsTranscoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_vtbl>())).LoadImageData as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(LoadImageData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtbl>())).SetImageFromMemory as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(SetImageFromMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtbl>())).SetImageFromStdioStream as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(SetImageFromStdioStream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtbl>())).WriteToStdioStream as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(WriteToStdioStream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtbl>())).WriteToNamedFile as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(WriteToNamedFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_vtbl>())).WriteToMemory as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(WriteToMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_vtbl>())).WriteToStream as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtbl),
            "::",
            stringify!(WriteToStream)
        )
    );
}
#[doc = " @class ktxTexture1"]
#[doc = " @~English"]
#[doc = " @brief Class representing a KTX version 1 format texture."]
#[doc = ""]
#[doc = " ktxTextures should be created only by one of the ktxTexture_Create*"]
#[doc = " functions and these fields should be considered read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture1 {
    pub classId: class_id,
    pub vtbl: *mut ktxTexture_vtbl,
    pub vvtbl: *mut ktxTexture_vvtbl,
    pub _protected: *mut ktxTexture_protected,
    pub isArray: ktx_bool_t,
    pub isCubemap: ktx_bool_t,
    pub isCompressed: ktx_bool_t,
    pub generateMipmaps: ktx_bool_t,
    pub baseWidth: ktx_uint32_t,
    pub baseHeight: ktx_uint32_t,
    pub baseDepth: ktx_uint32_t,
    pub numDimensions: ktx_uint32_t,
    pub numLevels: ktx_uint32_t,
    pub numLayers: ktx_uint32_t,
    pub numFaces: ktx_uint32_t,
    pub orientation: ktxOrientation,
    pub kvDataHead: ktxHashList,
    pub kvDataLen: ktx_uint32_t,
    pub kvData: *mut ktx_uint8_t,
    pub dataSize: ktx_size_t,
    pub pData: *mut ktx_uint8_t,
    #[doc = "< Format of the texture data, e.g., GL_RGB."]
    pub glFormat: ktx_uint32_t,
    #[doc = "< Internal format of the texture data,"]
    #[doc = "e.g., GL_RGB8."]
    pub glInternalformat: ktx_uint32_t,
    #[doc = "< Base format of the texture data,"]
    #[doc = "e.g., GL_RGB."]
    pub glBaseInternalformat: ktx_uint32_t,
    #[doc = "< Type of the texture data, e.g, GL_UNSIGNED_BYTE."]
    pub glType: ktx_uint32_t,
    #[doc = "< Private data."]
    pub _private: *mut ktxTexture1_private,
}
#[test]
fn bindgen_test_layout_ktxTexture1() {
    assert_eq!(
        ::std::mem::size_of::<ktxTexture1>(),
        144usize,
        concat!("Size of: ", stringify!(ktxTexture1))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxTexture1>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxTexture1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).classId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(classId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).vtbl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(vtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).vvtbl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(vvtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>()))._protected as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(_protected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).isArray as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(isArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).isCubemap as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(isCubemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).isCompressed as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(isCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).generateMipmaps as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(generateMipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).baseWidth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(baseWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).baseHeight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(baseHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).baseDepth as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(baseDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).numDimensions as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(numDimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).numLevels as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).numLayers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(numLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).numFaces as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(numFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).orientation as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).kvDataHead as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(kvDataHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).kvDataLen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(kvDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).kvData as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(kvData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).dataSize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).pData as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).glFormat as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(glFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).glInternalformat as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(glInternalformat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture1>())).glBaseInternalformat as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(glBaseInternalformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>())).glType as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(glType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture1>()))._private as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture1),
            "::",
            stringify!(_private)
        )
    );
}
#[doc = "< No supercompression."]
pub const ktxSupercmpScheme_KTX_SS_NONE: ktxSupercmpScheme = 0;
#[doc = "< Basis LZ supercompression."]
pub const ktxSupercmpScheme_KTX_SS_BASIS_LZ: ktxSupercmpScheme = 1;
#[doc = "< ZStd supercompression."]
pub const ktxSupercmpScheme_KTX_SS_ZSTD: ktxSupercmpScheme = 2;
pub const ktxSupercmpScheme_KTX_SS_BEGIN_RANGE: ktxSupercmpScheme = 0;
pub const ktxSupercmpScheme_KTX_SS_END_RANGE: ktxSupercmpScheme = 2;
pub const ktxSupercmpScheme_KTX_SS_BEGIN_VENDOR_RANGE: ktxSupercmpScheme = 65536;
pub const ktxSupercmpScheme_KTX_SS_END_VENDOR_RANGE: ktxSupercmpScheme = 131071;
pub const ktxSupercmpScheme_KTX_SS_BEGIN_RESERVED: ktxSupercmpScheme = 131072;
pub const ktxSupercmpScheme_KTX_SUPERCOMPRESSION_BASIS: ktxSupercmpScheme = 1;
pub const ktxSupercmpScheme_KTX_SUPERCOMPRESSION_ZSTD: ktxSupercmpScheme = 2;
#[doc = " @~English"]
#[doc = " @brief Enumerators identifying the supercompression scheme."]
pub type ktxSupercmpScheme = ::std::os::raw::c_uint;
#[doc = " @class ktxTexture2"]
#[doc = " @~English"]
#[doc = " @brief Class representing a KTX version 2 format texture."]
#[doc = ""]
#[doc = " ktxTextures should be created only by one of the ktxTexture_Create*"]
#[doc = " functions and these fields should be considered read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture2 {
    pub classId: class_id,
    pub vtbl: *mut ktxTexture_vtbl,
    pub vvtbl: *mut ktxTexture_vvtbl,
    pub _protected: *mut ktxTexture_protected,
    pub isArray: ktx_bool_t,
    pub isCubemap: ktx_bool_t,
    pub isCompressed: ktx_bool_t,
    pub generateMipmaps: ktx_bool_t,
    pub baseWidth: ktx_uint32_t,
    pub baseHeight: ktx_uint32_t,
    pub baseDepth: ktx_uint32_t,
    pub numDimensions: ktx_uint32_t,
    pub numLevels: ktx_uint32_t,
    pub numLayers: ktx_uint32_t,
    pub numFaces: ktx_uint32_t,
    pub orientation: ktxOrientation,
    pub kvDataHead: ktxHashList,
    pub kvDataLen: ktx_uint32_t,
    pub kvData: *mut ktx_uint8_t,
    pub dataSize: ktx_size_t,
    pub pData: *mut ktx_uint8_t,
    pub vkFormat: ktx_uint32_t,
    pub pDfd: *mut ktx_uint32_t,
    pub supercompressionScheme: ktxSupercmpScheme,
    pub isVideo: ktx_bool_t,
    pub duration: ktx_uint32_t,
    pub timescale: ktx_uint32_t,
    pub loopcount: ktx_uint32_t,
    #[doc = "< Private data."]
    pub _private: *mut ktxTexture2_private,
}
#[test]
fn bindgen_test_layout_ktxTexture2() {
    assert_eq!(
        ::std::mem::size_of::<ktxTexture2>(),
        168usize,
        concat!("Size of: ", stringify!(ktxTexture2))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxTexture2>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxTexture2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).classId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(classId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).vtbl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(vtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).vvtbl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(vvtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>()))._protected as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(_protected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).isArray as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(isArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).isCubemap as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(isCubemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).isCompressed as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(isCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).generateMipmaps as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(generateMipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).baseWidth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(baseWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).baseHeight as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(baseHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).baseDepth as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(baseDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).numDimensions as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(numDimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).numLevels as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).numLayers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(numLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).numFaces as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(numFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).orientation as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).kvDataHead as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(kvDataHead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).kvDataLen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(kvDataLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).kvData as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(kvData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).dataSize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).pData as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).vkFormat as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(vkFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).pDfd as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(pDfd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture2>())).supercompressionScheme as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(supercompressionScheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).isVideo as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(isVideo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).duration as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).timescale as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(timescale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>())).loopcount as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(loopcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture2>()))._private as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture2),
            "::",
            stringify!(_private)
        )
    );
}
#[doc = " @memberof ktxTexture"]
#[doc = " @~English"]
#[doc = " @brief Structure for passing texture information to ktxTexture[12]_Create()."]
#[doc = ""]
#[doc = " @sa ktxTexture_Create()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTextureCreateInfo {
    #[doc = "< Internal format for the texture, e.g.,"]
    #[doc = "GL_RGB8. Ignored when creating a"]
    #[doc = "ktxTexture2."]
    pub glInternalformat: ktx_uint32_t,
    #[doc = "< VkFormat for texture. Ignored when creating a"]
    #[doc = "ktxTexture1."]
    pub vkFormat: ktx_uint32_t,
    #[doc = "< Pointer to DFD. Used only when creating a"]
    #[doc = "ktxTexture2 and only if vkFormat is"]
    #[doc = "VK_FORMAT_UNDEFINED."]
    pub pDfd: *mut ktx_uint32_t,
    #[doc = "< Width of the base level of the texture."]
    pub baseWidth: ktx_uint32_t,
    #[doc = "< Height of the base level of the texture."]
    pub baseHeight: ktx_uint32_t,
    #[doc = "< Depth of the base level of the texture."]
    pub baseDepth: ktx_uint32_t,
    #[doc = "< Number of dimensions in the texture, 1, 2"]
    #[doc = "or 3."]
    pub numDimensions: ktx_uint32_t,
    #[doc = "< Number of mip levels in the texture. Should be"]
    #[doc = "1 if @c generateMipmaps is KTX_TRUE;"]
    pub numLevels: ktx_uint32_t,
    #[doc = "< Number of array layers in the texture."]
    pub numLayers: ktx_uint32_t,
    #[doc = "< Number of faces: 6 for cube maps, 1 otherwise."]
    pub numFaces: ktx_uint32_t,
    #[doc = "< Set to KTX_TRUE if the texture is to be an"]
    #[doc = "array texture. Means OpenGL will use a"]
    #[doc = "GL_TEXTURE_*_ARRAY target."]
    pub isArray: ktx_bool_t,
    #[doc = "< Set to KTX_TRUE if mipmaps should be"]
    #[doc = "generated for the texture when loading"]
    #[doc = "into a 3D API."]
    pub generateMipmaps: ktx_bool_t,
}
#[test]
fn bindgen_test_layout_ktxTextureCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<ktxTextureCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(ktxTextureCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxTextureCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxTextureCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTextureCreateInfo>())).glInternalformat as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(glInternalformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).vkFormat as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(vkFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).pDfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(pDfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).baseWidth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(baseWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).baseHeight as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(baseHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).baseDepth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(baseDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTextureCreateInfo>())).numDimensions as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(numDimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).numLevels as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(numLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).numLayers as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(numLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).numFaces as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(numFaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTextureCreateInfo>())).isArray as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(isArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTextureCreateInfo>())).generateMipmaps as *const _ as usize
        },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTextureCreateInfo),
            "::",
            stringify!(generateMipmaps)
        )
    );
}
#[doc = "< Don't allocate any image storage."]
pub const ktxTextureCreateStorageEnum_KTX_TEXTURE_CREATE_NO_STORAGE: ktxTextureCreateStorageEnum =
    0;
#[doc = "< Allocate image storage."]
pub const ktxTextureCreateStorageEnum_KTX_TEXTURE_CREATE_ALLOC_STORAGE:
    ktxTextureCreateStorageEnum = 1;
#[doc = " @memberof ktxTexture"]
#[doc = " @~English"]
#[doc = " @brief Enum for requesting, or not, allocation of storage for images."]
#[doc = ""]
#[doc = " @sa ktxTexture_Create()"]
pub type ktxTextureCreateStorageEnum = ::std::os::raw::c_uint;
pub const ktxTextureCreateFlagBits_KTX_TEXTURE_CREATE_NO_FLAGS: ktxTextureCreateFlagBits = 0;
pub const ktxTextureCreateFlagBits_KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT:
    ktxTextureCreateFlagBits = 1;
pub const ktxTextureCreateFlagBits_KTX_TEXTURE_CREATE_RAW_KVDATA_BIT: ktxTextureCreateFlagBits = 2;
pub const ktxTextureCreateFlagBits_KTX_TEXTURE_CREATE_SKIP_KVDATA_BIT: ktxTextureCreateFlagBits = 4;
#[doc = " @memberof ktxTexture"]
#[doc = " @~English"]
#[doc = " @brief Flags for requesting services during creation."]
#[doc = ""]
#[doc = " @sa ktxTexture_CreateFrom*"]
pub type ktxTextureCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " @memberof ktxTexture"]
#[doc = " @~English"]
#[doc = " @brief Type for TextureCreateFlags parameters."]
#[doc = ""]
#[doc = " @sa ktxTexture_CreateFrom*()"]
pub type ktxTextureCreateFlags = ktx_uint32_t;
pub type ktx_off_t = off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxMem {
    _unused: [u8; 0],
}
pub const streamType_eStreamTypeFile: streamType = 1;
pub const streamType_eStreamTypeMemory: streamType = 2;
pub const streamType_eStreamTypeCustom: streamType = 3;
pub type streamType = ::std::os::raw::c_uint;
#[doc = " @~English"]
#[doc = " @brief type for a pointer to a stream reading function"]
pub type ktxStream_read = ::std::option::Option<
    unsafe extern "C" fn(
        str_: *mut ktxStream,
        dst: *mut ::std::os::raw::c_void,
        count: ktx_size_t,
    ) -> ktx_error_code_e,
>;
#[doc = " @~English"]
#[doc = " @brief type for a pointer to a stream skipping function"]
pub type ktxStream_skip = ::std::option::Option<
    unsafe extern "C" fn(str_: *mut ktxStream, count: ktx_size_t) -> ktx_error_code_e,
>;
#[doc = " @~English"]
#[doc = " @brief type for a pointer to a stream reading function"]
pub type ktxStream_write = ::std::option::Option<
    unsafe extern "C" fn(
        str_: *mut ktxStream,
        src: *const ::std::os::raw::c_void,
        size: ktx_size_t,
        count: ktx_size_t,
    ) -> ktx_error_code_e,
>;
#[doc = " @~English"]
#[doc = " @brief type for a pointer to a stream position query function"]
pub type ktxStream_getpos = ::std::option::Option<
    unsafe extern "C" fn(str_: *mut ktxStream, offset: *mut ktx_off_t) -> ktx_error_code_e,
>;
#[doc = " @~English"]
#[doc = " @brief type for a pointer to a stream position query function"]
pub type ktxStream_setpos = ::std::option::Option<
    unsafe extern "C" fn(str_: *mut ktxStream, offset: ktx_off_t) -> ktx_error_code_e,
>;
#[doc = " @~English"]
#[doc = " @brief type for a pointer to a stream size query function"]
pub type ktxStream_getsize = ::std::option::Option<
    unsafe extern "C" fn(str_: *mut ktxStream, size: *mut ktx_size_t) -> ktx_error_code_e,
>;
#[doc = " @~English"]
#[doc = " @brief Destruct a stream"]
pub type ktxStream_destruct = ::std::option::Option<unsafe extern "C" fn(str_: *mut ktxStream)>;
#[doc = " @~English"]
#[doc = ""]
#[doc = " @brief Interface of ktxStream."]
#[doc = ""]
#[doc = " @author Maksim Kolesin"]
#[doc = " @author Georg Kolling, Imagination Technology"]
#[doc = " @author Mark Callow, HI Corporation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ktxStream {
    #[doc = "< @internal pointer to function for reading bytes."]
    pub read: ktxStream_read,
    #[doc = "< @internal pointer to function for skipping bytes."]
    pub skip: ktxStream_skip,
    #[doc = "< @internal pointer to function for writing bytes."]
    pub write: ktxStream_write,
    #[doc = "< @internal pointer to function for getting current position in stream."]
    pub getpos: ktxStream_getpos,
    #[doc = "< @internal pointer to function for setting current position in stream."]
    pub setpos: ktxStream_setpos,
    #[doc = "< @internal pointer to function for querying size."]
    pub getsize: ktxStream_getsize,
    #[doc = "< @internal destruct the stream."]
    pub destruct: ktxStream_destruct,
    pub type_: streamType,
    #[doc = "< @internal pointer to the stream data."]
    pub data: ktxStream__bindgen_ty_1,
    #[doc = "< @internal used by FileStream for stdin."]
    pub readpos: ktx_off_t,
    #[doc = "< @internal Close FILE* or dispose of memory on destruct."]
    pub closeOnDestruct: ktx_bool_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ktxStream__bindgen_ty_1 {
    pub file: *mut FILE,
    pub mem: *mut ktxMem,
    pub custom_ptr: ktxStream__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxStream__bindgen_ty_1__bindgen_ty_1 {
    pub address: *mut ::std::os::raw::c_void,
    pub allocatorAddress: *mut ::std::os::raw::c_void,
    pub size: ktx_size_t,
}
#[test]
fn bindgen_test_layout_ktxStream__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ktxStream__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ktxStream__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ktxStream__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ktxStream__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxStream__bindgen_ty_1__bindgen_ty_1>())).address as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxStream__bindgen_ty_1__bindgen_ty_1>())).allocatorAddress
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(allocatorAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxStream__bindgen_ty_1__bindgen_ty_1>())).size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_ktxStream__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ktxStream__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(ktxStream__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxStream__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxStream__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream__bindgen_ty_1>())).file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream__bindgen_ty_1),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxStream__bindgen_ty_1>())).custom_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream__bindgen_ty_1),
            "::",
            stringify!(custom_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_ktxStream() {
    assert_eq!(
        ::std::mem::size_of::<ktxStream>(),
        104usize,
        concat!("Size of: ", stringify!(ktxStream))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxStream>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).skip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).write as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).getpos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(getpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).setpos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(setpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).getsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(getsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).destruct as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(destruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).type_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).data as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).readpos as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(readpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxStream>())).closeOnDestruct as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxStream),
            "::",
            stringify!(closeOnDestruct)
        )
    );
}
extern "C" {
    #[doc = " These four create a ktxTexture1 or ktxTexture2 according to the data"]
    #[doc = " header, and return a pointer to the base ktxTexture class."]
    pub fn ktxTexture_CreateFromStdioStream(
        stdioStream: *mut FILE,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture_CreateFromNamedFile(
        filename: *const ::std::os::raw::c_char,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture_CreateFromMemory(
        bytes: *const ktx_uint8_t,
        size: ktx_size_t,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture_CreateFromStream(
        stream: *mut ktxStream,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Returns a pointer to the image data of a ktxTexture object."]
    pub fn ktxTexture_GetData(This: *mut ktxTexture) -> *mut ktx_uint8_t;
}
extern "C" {
    #[doc = " Returns the pitch of a row of an image at the specified level."]
    #[doc = " Similar to the rowPitch in a VkSubResourceLayout."]
    pub fn ktxTexture_GetRowPitch(This: *mut ktxTexture, level: ktx_uint32_t) -> ktx_uint32_t;
}
extern "C" {
    #[doc = " Return the element size of the texture's images."]
    pub fn ktxTexture_GetElementSize(This: *mut ktxTexture) -> ktx_uint32_t;
}
extern "C" {
    #[doc = " Returns the size of all the image data of a ktxTexture object in bytes."]
    pub fn ktxTexture_GetDataSize(This: *mut ktxTexture) -> ktx_size_t;
}
extern "C" {
    #[doc = " Uploads a texture to OpenGL {,ES}."]
    pub fn ktxTexture_GLUpload(
        This: *mut ktxTexture,
        pTexture: *mut GLuint,
        pTarget: *mut GLenum,
        pGlerror: *mut GLenum,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Iterate over the levels or faces in a ktxTexture object."]
    pub fn ktxTexture_IterateLevelFaces(
        This: *mut ktxTexture,
        iterCb: PFNKTXITERCB,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Create a new ktxTexture1."]
    pub fn ktxTexture1_Create(
        createInfo: *mut ktxTextureCreateInfo,
        storageAllocation: ktxTextureCreateStorageEnum,
        newTex: *mut *mut ktxTexture1,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " These four create a ktxTexture1 provided the data is in KTX format."]
    pub fn ktxTexture1_CreateFromStdioStream(
        stdioStream: *mut FILE,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture1,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture1_CreateFromNamedFile(
        filename: *const ::std::os::raw::c_char,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture1,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture1_CreateFromMemory(
        bytes: *const ktx_uint8_t,
        size: ktx_size_t,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture1,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture1_CreateFromStream(
        stream: *mut ktxStream,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture1,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture1_NeedsTranscoding(This: *mut ktxTexture1) -> ktx_bool_t;
}
extern "C" {
    #[doc = " Write a ktxTexture object to a stdio stream in KTX format."]
    pub fn ktxTexture1_WriteKTX2ToStdioStream(
        This: *mut ktxTexture1,
        dstsstr: *mut FILE,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Write a ktxTexture object to a named file in KTX format."]
    pub fn ktxTexture1_WriteKTX2ToNamedFile(
        This: *mut ktxTexture1,
        dstname: *const ::std::os::raw::c_char,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Write a ktxTexture object to a block of memory in KTX format."]
    pub fn ktxTexture1_WriteKTX2ToMemory(
        This: *mut ktxTexture1,
        bytes: *mut *mut ktx_uint8_t,
        size: *mut ktx_size_t,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Write a ktxTexture object to a ktxStream in KTX format."]
    pub fn ktxTexture1_WriteKTX2ToStream(
        This: *mut ktxTexture1,
        dststr: *mut ktxStream,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Create a new ktxTexture2."]
    pub fn ktxTexture2_Create(
        createInfo: *mut ktxTextureCreateInfo,
        storageAllocation: ktxTextureCreateStorageEnum,
        newTex: *mut *mut ktxTexture2,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Create a new ktxTexture2 as a copy of an existing texture."]
    pub fn ktxTexture2_CreateCopy(
        orig: *mut ktxTexture2,
        newTex: *mut *mut ktxTexture2,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " These four create a ktxTexture2 provided the data is in KTX2 format."]
    pub fn ktxTexture2_CreateFromStdioStream(
        stdioStream: *mut FILE,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture2,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture2_CreateFromNamedFile(
        filename: *const ::std::os::raw::c_char,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture2,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture2_CreateFromMemory(
        bytes: *const ktx_uint8_t,
        size: ktx_size_t,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture2,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture2_CreateFromStream(
        stream: *mut ktxStream,
        createFlags: ktxTextureCreateFlags,
        newTex: *mut *mut ktxTexture2,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture2_CompressBasis(
        This: *mut ktxTexture2,
        quality: ktx_uint32_t,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture2_DeflateZstd(This: *mut ktxTexture2, level: ktx_uint32_t)
        -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture2_GetComponentInfo(
        This: *mut ktxTexture2,
        numComponents: *mut ktx_uint32_t,
        componentByteLength: *mut ktx_uint32_t,
    );
}
extern "C" {
    pub fn ktxTexture2_GetNumComponents(This: *mut ktxTexture2) -> ktx_uint32_t;
}
extern "C" {
    pub fn ktxTexture2_GetOETF(This: *mut ktxTexture2) -> ktx_uint32_t;
}
extern "C" {
    pub fn ktxTexture2_GetPremultipliedAlpha(This: *mut ktxTexture2) -> ktx_bool_t;
}
extern "C" {
    pub fn ktxTexture2_NeedsTranscoding(This: *mut ktxTexture2) -> ktx_bool_t;
}
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_LEVEL_FASTEST: ktx_pack_uastc_flag_bits_e = 0;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_LEVEL_FASTER: ktx_pack_uastc_flag_bits_e = 1;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_LEVEL_DEFAULT: ktx_pack_uastc_flag_bits_e = 2;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_LEVEL_SLOWER: ktx_pack_uastc_flag_bits_e = 3;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_LEVEL_VERYSLOW: ktx_pack_uastc_flag_bits_e = 4;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_MAX_LEVEL: ktx_pack_uastc_flag_bits_e = 4;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_LEVEL_MASK: ktx_pack_uastc_flag_bits_e = 15;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_FAVOR_UASTC_ERROR: ktx_pack_uastc_flag_bits_e =
    8;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_FAVOR_BC7_ERROR: ktx_pack_uastc_flag_bits_e =
    16;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_ETC1_FASTER_HINTS: ktx_pack_uastc_flag_bits_e =
    64;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC_ETC1_FASTEST_HINTS: ktx_pack_uastc_flag_bits_e =
    128;
pub const ktx_pack_uastc_flag_bits_e_KTX_PACK_UASTC__ETC1_DISABLE_FLIP_AND_INDIVIDUAL:
    ktx_pack_uastc_flag_bits_e = 256;
#[doc = " @~English"]
#[doc = " @brief Flags specifiying UASTC encoding options."]
pub type ktx_pack_uastc_flag_bits_e = ::std::os::raw::c_uint;
pub type ktx_pack_uastc_flags = ktx_uint32_t;
extern "C" {
    pub static KTX_ETC1S_DEFAULT_COMPRESSION_LEVEL: ktx_uint32_t;
}
#[doc = " @memberof ktxTexture2"]
#[doc = " @~English"]
#[doc = " @brief Structure for passing extended parameters to"]
#[doc = "        ktxTexture2_CompressBasisEx."]
#[doc = ""]
#[doc = " Passing a struct initialized to 0 (e.g. \" = {};\") will use the default"]
#[doc = " values. Only those settings to be modified need be non-zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxBasisParams {
    pub structSize: ktx_uint32_t,
    pub uastc: ktx_bool_t,
    pub verbose: ktx_bool_t,
    pub noSSE: ktx_bool_t,
    pub threadCount: ktx_uint32_t,
    #[doc = " ETC1S params"]
    pub compressionLevel: ktx_uint32_t,
    pub qualityLevel: ktx_uint32_t,
    pub maxEndpoints: ktx_uint32_t,
    pub endpointRDOThreshold: f32,
    pub maxSelectors: ktx_uint32_t,
    pub selectorRDOThreshold: f32,
    pub inputSwizzle: [::std::os::raw::c_char; 4usize],
    pub normalMap: ktx_bool_t,
    pub separateRGToRGB_A: ktx_bool_t,
    pub preSwizzle: ktx_bool_t,
    pub noEndpointRDO: ktx_bool_t,
    pub noSelectorRDO: ktx_bool_t,
    #[doc = " UASTC params"]
    pub uastcFlags: ktx_pack_uastc_flags,
    pub uastcRDO: ktx_bool_t,
    pub uastcRDOQualityScalar: f32,
    pub uastcRDODictSize: ktx_uint32_t,
    pub uastcRDOMaxSmoothBlockErrorScale: f32,
    pub uastcRDOMaxSmoothBlockStdDev: f32,
    pub uastcRDODontFavorSimplerModes: ktx_bool_t,
    pub uastcRDONoMultithreading: ktx_bool_t,
}
#[test]
fn bindgen_test_layout_ktxBasisParams() {
    assert_eq!(
        ::std::mem::size_of::<ktxBasisParams>(),
        76usize,
        concat!("Size of: ", stringify!(ktxBasisParams))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxBasisParams>(),
        4usize,
        concat!("Alignment of ", stringify!(ktxBasisParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).structSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).uastc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).verbose as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).noSSE as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(noSSE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).threadCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(threadCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).compressionLevel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(compressionLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).qualityLevel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(qualityLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).maxEndpoints as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(maxEndpoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).endpointRDOThreshold as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(endpointRDOThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).maxSelectors as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(maxSelectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).selectorRDOThreshold as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(selectorRDOThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).inputSwizzle as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(inputSwizzle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).normalMap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(normalMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).separateRGToRGB_A as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(separateRGToRGB_A)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).preSwizzle as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(preSwizzle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).noEndpointRDO as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(noEndpointRDO)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).noSelectorRDO as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(noSelectorRDO)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).uastcFlags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).uastcRDO as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcRDO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).uastcRDOQualityScalar as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcRDOQualityScalar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxBasisParams>())).uastcRDODictSize as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcRDODictSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).uastcRDOMaxSmoothBlockErrorScale as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcRDOMaxSmoothBlockErrorScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).uastcRDOMaxSmoothBlockStdDev as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcRDOMaxSmoothBlockStdDev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).uastcRDODontFavorSimplerModes as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcRDODontFavorSimplerModes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxBasisParams>())).uastcRDONoMultithreading as *const _ as usize
        },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxBasisParams),
            "::",
            stringify!(uastcRDONoMultithreading)
        )
    );
}
extern "C" {
    pub fn ktxTexture2_CompressBasisEx(
        This: *mut ktxTexture2,
        params: *mut ktxBasisParams,
    ) -> ktx_error_code_e;
}
#[doc = " ETC1-2"]
pub const ktx_transcode_fmt_e_KTX_TTF_ETC1_RGB: ktx_transcode_fmt_e = 0;
pub const ktx_transcode_fmt_e_KTX_TTF_ETC2_RGBA: ktx_transcode_fmt_e = 1;
#[doc = " BC1-5, BC7 (desktop, some mobile devices)"]
pub const ktx_transcode_fmt_e_KTX_TTF_BC1_RGB: ktx_transcode_fmt_e = 2;
pub const ktx_transcode_fmt_e_KTX_TTF_BC3_RGBA: ktx_transcode_fmt_e = 3;
pub const ktx_transcode_fmt_e_KTX_TTF_BC4_R: ktx_transcode_fmt_e = 4;
pub const ktx_transcode_fmt_e_KTX_TTF_BC5_RG: ktx_transcode_fmt_e = 5;
pub const ktx_transcode_fmt_e_KTX_TTF_BC7_RGBA: ktx_transcode_fmt_e = 6;
#[doc = " PVRTC1 4bpp (mobile, PowerVR devices)"]
pub const ktx_transcode_fmt_e_KTX_TTF_PVRTC1_4_RGB: ktx_transcode_fmt_e = 8;
pub const ktx_transcode_fmt_e_KTX_TTF_PVRTC1_4_RGBA: ktx_transcode_fmt_e = 9;
#[doc = " ASTC (mobile, Intel devices, hopefully all desktop GPU's one day)"]
pub const ktx_transcode_fmt_e_KTX_TTF_ASTC_4x4_RGBA: ktx_transcode_fmt_e = 10;
#[doc = " ATC and FXT1 formats are not supported by KTX2 as there"]
#[doc = " are no equivalent VkFormats."]
pub const ktx_transcode_fmt_e_KTX_TTF_PVRTC2_4_RGB: ktx_transcode_fmt_e = 18;
pub const ktx_transcode_fmt_e_KTX_TTF_PVRTC2_4_RGBA: ktx_transcode_fmt_e = 19;
pub const ktx_transcode_fmt_e_KTX_TTF_ETC2_EAC_R11: ktx_transcode_fmt_e = 20;
pub const ktx_transcode_fmt_e_KTX_TTF_ETC2_EAC_RG11: ktx_transcode_fmt_e = 21;
#[doc = " Uncompressed (raw pixel) formats"]
pub const ktx_transcode_fmt_e_KTX_TTF_RGBA32: ktx_transcode_fmt_e = 13;
pub const ktx_transcode_fmt_e_KTX_TTF_RGB565: ktx_transcode_fmt_e = 14;
pub const ktx_transcode_fmt_e_KTX_TTF_BGR565: ktx_transcode_fmt_e = 15;
pub const ktx_transcode_fmt_e_KTX_TTF_RGBA4444: ktx_transcode_fmt_e = 16;
#[doc = " Values for automatic selection of RGB or RGBA depending if alpha"]
#[doc = " present."]
pub const ktx_transcode_fmt_e_KTX_TTF_ETC: ktx_transcode_fmt_e = 22;
pub const ktx_transcode_fmt_e_KTX_TTF_BC1_OR_3: ktx_transcode_fmt_e = 23;
pub const ktx_transcode_fmt_e_KTX_TTF_NOSELECTION: ktx_transcode_fmt_e = 2147483647;
#[doc = " Old enums for compatibility with code compiled against previous"]
#[doc = " versions of libktx."]
pub const ktx_transcode_fmt_e_KTX_TF_ETC1: ktx_transcode_fmt_e = 0;
pub const ktx_transcode_fmt_e_KTX_TF_ETC2: ktx_transcode_fmt_e = 22;
pub const ktx_transcode_fmt_e_KTX_TF_BC1: ktx_transcode_fmt_e = 2;
pub const ktx_transcode_fmt_e_KTX_TF_BC3: ktx_transcode_fmt_e = 3;
pub const ktx_transcode_fmt_e_KTX_TF_BC4: ktx_transcode_fmt_e = 4;
pub const ktx_transcode_fmt_e_KTX_TF_BC5: ktx_transcode_fmt_e = 5;
pub const ktx_transcode_fmt_e_KTX_TTF_BC7_M6_RGB: ktx_transcode_fmt_e = 6;
pub const ktx_transcode_fmt_e_KTX_TTF_BC7_M5_RGBA: ktx_transcode_fmt_e = 6;
pub const ktx_transcode_fmt_e_KTX_TF_BC7_M6_OPAQUE_ONLY: ktx_transcode_fmt_e = 6;
pub const ktx_transcode_fmt_e_KTX_TF_PVRTC1_4_OPAQUE_ONLY: ktx_transcode_fmt_e = 8;
#[doc = " @~English"]
#[doc = " @brief Enumerators for specifying the transcode target format."]
#[doc = ""]
#[doc = " For BasisU/ETC1S format, @e Opaque and @e alpha here refer to 2 separate"]
#[doc = " RGB images, a.k.a slices within the BasisU compressed data. For UASTC"]
#[doc = " format they refer to the RGB and the alpha components of the UASTC data. If"]
#[doc = " the original image had only 2 components, R will be in the opaque portion"]
#[doc = " and G in the alpha portion. The R value will be replicated in the RGB"]
#[doc = " components. In the case of BasisU the G value will be replicated in all 3"]
#[doc = " components of the alpha slice. If the original image had only 1 component"]
#[doc = " it's value is replicated in all 3 components of the opaque portion and"]
#[doc = " there is no alpha."]
#[doc = ""]
#[doc = " @note You should not transcode sRGB encoded data to @c KTX_TTF_BC4_R,"]
#[doc = " @c KTX_TTF_BC5_RG, @c KTX_TTF_ETC2_EAC_R{,G}11, @c KTX_TTF_RGB565,"]
#[doc = " @c KTX_TTF_BGR565 or @c KTX_TTF_RGBA4444 formats as neither OpenGL nor"]
#[doc = " Vulkan support sRGB variants of these. Doing sRGB decoding in the shader"]
#[doc = " will not produce correct results if any texture filtering is being used."]
pub type ktx_transcode_fmt_e = ::std::os::raw::c_uint;
pub const ktx_transcode_flag_bits_e_KTX_TF_PVRTC_DECODE_TO_NEXT_POW2: ktx_transcode_flag_bits_e = 2;
pub const ktx_transcode_flag_bits_e_KTX_TF_TRANSCODE_ALPHA_DATA_TO_OPAQUE_FORMATS:
    ktx_transcode_flag_bits_e = 4;
pub const ktx_transcode_flag_bits_e_KTX_TF_HIGH_QUALITY: ktx_transcode_flag_bits_e = 32;
#[doc = " @~English"]
#[doc = " @brief Flags guiding transcoding of Basis Universal compressed textures."]
pub type ktx_transcode_flag_bits_e = ::std::os::raw::c_uint;
pub type ktx_transcode_flags = ktx_uint32_t;
extern "C" {
    pub fn ktxTexture2_TranscodeBasis(
        This: *mut ktxTexture2,
        fmt: ktx_transcode_fmt_e,
        transcodeFlags: ktx_transcode_flags,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Returns a string corresponding to a KTX error code."]
    pub fn ktxErrorString(error: ktx_error_code_e) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a string corresponding to a supercompression scheme."]
    pub fn ktxSupercompressionSchemeString(
        scheme: ktxSupercmpScheme,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a string corresponding to a transcode target format."]
    pub fn ktxTranscodeFormatString(format: ktx_transcode_fmt_e) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ktxHashList_Create(ppHl: *mut *mut ktxHashList) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxHashList_CreateCopy(
        ppHl: *mut *mut ktxHashList,
        orig: ktxHashList,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxHashList_Construct(pHl: *mut ktxHashList);
}
extern "C" {
    pub fn ktxHashList_ConstructCopy(pHl: *mut ktxHashList, orig: ktxHashList);
}
extern "C" {
    pub fn ktxHashList_Destroy(head: *mut ktxHashList);
}
extern "C" {
    pub fn ktxHashList_Destruct(head: *mut ktxHashList);
}
extern "C" {
    #[doc = " Adds a key-value pair to a hash list."]
    pub fn ktxHashList_AddKVPair(
        pHead: *mut ktxHashList,
        key: *const ::std::os::raw::c_char,
        valueLen: ::std::os::raw::c_uint,
        value: *const ::std::os::raw::c_void,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Deletes a ktxHashListEntry from a ktxHashList."]
    pub fn ktxHashList_DeleteEntry(
        pHead: *mut ktxHashList,
        pEntry: *mut ktxHashListEntry,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Finds the entry for a key in a ktxHashList and deletes it."]
    pub fn ktxHashList_DeleteKVPair(
        pHead: *mut ktxHashList,
        key: *const ::std::os::raw::c_char,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Looks up a key and returns the ktxHashListEntry."]
    pub fn ktxHashList_FindEntry(
        pHead: *mut ktxHashList,
        key: *const ::std::os::raw::c_char,
        ppEntry: *mut *mut ktxHashListEntry,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Looks up a key and returns the value."]
    pub fn ktxHashList_FindValue(
        pHead: *mut ktxHashList,
        key: *const ::std::os::raw::c_char,
        pValueLen: *mut ::std::os::raw::c_uint,
        pValue: *mut *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Return the next entry in a ktxHashList."]
    pub fn ktxHashList_Next(entry: *mut ktxHashListEntry) -> *mut ktxHashListEntry;
}
extern "C" {
    #[doc = " Sorts a ktxHashList into order of the key codepoints."]
    pub fn ktxHashList_Sort(pHead: *mut ktxHashList) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Serializes a ktxHashList to a block of memory suitable for"]
    #[doc = " writing to a KTX file."]
    pub fn ktxHashList_Serialize(
        pHead: *mut ktxHashList,
        kvdLen: *mut ::std::os::raw::c_uint,
        kvd: *mut *mut ::std::os::raw::c_uchar,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Creates a hash table from the serialized data read from a"]
    #[doc = " a KTX file."]
    pub fn ktxHashList_Deserialize(
        pHead: *mut ktxHashList,
        kvdLen: ::std::os::raw::c_uint,
        kvd: *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Get the key from a ktxHashListEntry"]
    pub fn ktxHashListEntry_GetKey(
        This: *mut ktxHashListEntry,
        pKeyLen: *mut ::std::os::raw::c_uint,
        ppKey: *mut *mut ::std::os::raw::c_char,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = " Get the value from a ktxHashListEntry"]
    pub fn ktxHashListEntry_GetValue(
        This: *mut ktxHashListEntry,
        pValueLen: *mut ::std::os::raw::c_uint,
        ppValue: *mut *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e;
}
extern "C" {
    #[doc = "===========================================================*"]
    #[doc = " Utilities for printing info about a KTX file.             *"]
    #[doc = "==========================================================="]
    pub fn ktxPrintInfoForStdioStream(stdioStream: *mut FILE) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxPrintInfoForNamedFile(filename: *const ::std::os::raw::c_char) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxPrintInfoForMemory(bytes: *const ktx_uint8_t, size: ktx_size_t) -> ktx_error_code_e;
}
pub const ktxFormatSizeFlagBits_KTX_FORMAT_SIZE_PACKED_BIT: ktxFormatSizeFlagBits = 1;
pub const ktxFormatSizeFlagBits_KTX_FORMAT_SIZE_COMPRESSED_BIT: ktxFormatSizeFlagBits = 2;
pub const ktxFormatSizeFlagBits_KTX_FORMAT_SIZE_PALETTIZED_BIT: ktxFormatSizeFlagBits = 4;
pub const ktxFormatSizeFlagBits_KTX_FORMAT_SIZE_DEPTH_BIT: ktxFormatSizeFlagBits = 8;
pub const ktxFormatSizeFlagBits_KTX_FORMAT_SIZE_STENCIL_BIT: ktxFormatSizeFlagBits = 16;
pub type ktxFormatSizeFlagBits = ::std::os::raw::c_uint;
pub type ktxFormatSizeFlags = ktx_uint32_t;
#[doc = " @brief Structure for holding size information for a texture format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxFormatSize {
    pub flags: ktxFormatSizeFlags,
    #[doc = " For KTX1."]
    pub paletteSizeInBits: ::std::os::raw::c_uint,
    pub blockSizeInBits: ::std::os::raw::c_uint,
    #[doc = " in texels"]
    pub blockWidth: ::std::os::raw::c_uint,
    #[doc = " in texels"]
    pub blockHeight: ::std::os::raw::c_uint,
    #[doc = " in texels"]
    pub blockDepth: ::std::os::raw::c_uint,
    #[doc = " Minimum required number of blocks"]
    pub minBlocksX: ::std::os::raw::c_uint,
    pub minBlocksY: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ktxFormatSize() {
    assert_eq!(
        ::std::mem::size_of::<ktxFormatSize>(),
        32usize,
        concat!("Size of: ", stringify!(ktxFormatSize))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxFormatSize>(),
        4usize,
        concat!("Alignment of ", stringify!(ktxFormatSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).paletteSizeInBits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(paletteSizeInBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).blockSizeInBits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(blockSizeInBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).blockWidth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(blockWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).blockHeight as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(blockHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).blockDepth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(blockDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).minBlocksX as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(minBlocksX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxFormatSize>())).minBlocksY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxFormatSize),
            "::",
            stringify!(minBlocksY)
        )
    );
}
extern "C" {
    pub fn ktxFormatSize_initFromDfd(This: *mut ktxFormatSize, pDfd: *mut ktx_uint32_t) -> bool;
}
pub const ktxFormatVersionEnum_KTX_FORMAT_VERSION_ONE: ktxFormatVersionEnum = 1;
pub const ktxFormatVersionEnum_KTX_FORMAT_VERSION_TWO: ktxFormatVersionEnum = 2;
pub type ktxFormatVersionEnum = ::std::os::raw::c_uint;
pub type PFNCALCDATASIZELEVELS = ::std::option::Option<
    unsafe extern "C" fn(This: *mut ktxTexture, levels: ktx_uint32_t) -> ktx_size_t,
>;
pub type PFNCALCFACELODSIZE = ::std::option::Option<
    unsafe extern "C" fn(This: *mut ktxTexture, level: ktx_uint32_t) -> ktx_size_t,
>;
pub type PFNCALCLEVELOFFSET = ::std::option::Option<
    unsafe extern "C" fn(This: *mut ktxTexture, level: ktx_uint32_t) -> ktx_size_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture_vtblInt {
    pub calcDataSizeLevels: PFNCALCDATASIZELEVELS,
    pub calcFaceLodSize: PFNCALCFACELODSIZE,
    pub calcLevelOffset: PFNCALCLEVELOFFSET,
}
#[test]
fn bindgen_test_layout_ktxTexture_vtblInt() {
    assert_eq!(
        ::std::mem::size_of::<ktxTexture_vtblInt>(),
        24usize,
        concat!("Size of: ", stringify!(ktxTexture_vtblInt))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxTexture_vtblInt>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxTexture_vtblInt))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtblInt>())).calcDataSizeLevels as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtblInt),
            "::",
            stringify!(calcDataSizeLevels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtblInt>())).calcFaceLodSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtblInt),
            "::",
            stringify!(calcFaceLodSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_vtblInt>())).calcLevelOffset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_vtblInt),
            "::",
            stringify!(calcLevelOffset)
        )
    );
}
#[doc = " @memberof ktxTexture"]
#[doc = " @~English"]
#[doc = ""]
#[doc = " @brief protected members of ktxTexture."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ktxTexture_protected {
    pub _vtbl: ktxTexture_vtblInt,
    pub _formatSize: ktxFormatSize,
    pub _typeSize: ktx_uint32_t,
    pub _stream: ktxStream,
}
#[test]
fn bindgen_test_layout_ktxTexture_protected() {
    assert_eq!(
        ::std::mem::size_of::<ktxTexture_protected>(),
        168usize,
        concat!("Size of: ", stringify!(ktxTexture_protected))
    );
    assert_eq!(
        ::std::mem::align_of::<ktxTexture_protected>(),
        8usize,
        concat!("Alignment of ", stringify!(ktxTexture_protected))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_protected>()))._vtbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_protected),
            "::",
            stringify!(_vtbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ktxTexture_protected>()))._formatSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_protected),
            "::",
            stringify!(_formatSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_protected>()))._typeSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_protected),
            "::",
            stringify!(_typeSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktxTexture_protected>()))._stream as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ktxTexture_protected),
            "::",
            stringify!(_stream)
        )
    );
}
extern "C" {
    pub fn ktxTexture_iterateLoadedImages(
        This: *mut ktxTexture,
        iterCb: PFNKTXITERCB,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture_iterateSourceImages(
        This: *mut ktxTexture,
        iterCb: PFNKTXITERCB,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture_calcDataSizeTexture(This: *mut ktxTexture) -> ktx_size_t;
}
extern "C" {
    pub fn ktxTexture_calcImageSize(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        fv: ktxFormatVersionEnum,
    ) -> ktx_size_t;
}
extern "C" {
    pub fn ktxTexture_isActiveStream(This: *mut ktxTexture) -> ktx_bool_t;
}
extern "C" {
    pub fn ktxTexture_calcLevelSize(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        fv: ktxFormatVersionEnum,
    ) -> ktx_size_t;
}
extern "C" {
    pub fn ktxTexture_doCalcFaceLodSize(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        fv: ktxFormatVersionEnum,
    ) -> ktx_size_t;
}
extern "C" {
    pub fn ktxTexture_layerSize(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        fv: ktxFormatVersionEnum,
    ) -> ktx_size_t;
}
extern "C" {
    pub fn ktxTexture_rowInfo(
        This: *mut ktxTexture,
        level: ktx_uint32_t,
        numRows: *mut ktx_uint32_t,
        rowBytes: *mut ktx_uint32_t,
        rowPadding: *mut ktx_uint32_t,
    );
}
extern "C" {
    pub fn ktxTexture_construct(
        This: *mut ktxTexture,
        createInfo: *mut ktxTextureCreateInfo,
        formatSize: *mut ktxFormatSize,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture_constructFromStream(
        This: *mut ktxTexture,
        pStream: *mut ktxStream,
        createFlags: ktxTextureCreateFlags,
    ) -> ktx_error_code_e;
}
extern "C" {
    pub fn ktxTexture_destruct(This: *mut ktxTexture);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture_vvtbl {
    pub _address: u8,
}
#[doc = "< Private data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture1_private {
    pub _address: u8,
}
#[doc = "< Private data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktxTexture2_private {
    pub _address: u8,
}
